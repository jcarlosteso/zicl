## Why did I choose this format

Since the first iteration didn't pan out, I wanted to try something different for this one. Instead of wandering around the features of ZIL looking for the next best thing to include into my project and, once I chose one, start digging into it and coding it in Clojure, this time **I'd like to take a more organized, top-down approach.**

This will imply:

1. Starting with an overview of the _modules_ ZIL is composed of, what does every one of them do, and how do they interact. Also, making the first design choices and writing some code as a sort of scaffolding for the rest of the project.
1. Defining an initial _roadmap_ for the project, taking only into account the "big blocks".
1. Following the roadmap to analyze, split if necessary, and design features. Adjust the roadmap if needed.
1. Repeat the previous step until the project is done.

### Ok, but… why _this_ format?

Oh, right. Right. Well, because **I have no idea how long will each feature take to be built.** Switching from posts to documents managed by a version control system allows me to:

* Stick to my initial intention of having a working product at the end of each iteration.
* Use [semantic versioning](https://semver.org/) and [git tags](https://git-scm.com/book/en/v2/Git-Basics-Tagging) for both the code and the docs that explain its desing choices, without the need of keeping a narrative or a discourse.
* Differentiate between what is considered a "published" version of code & docs (which will be both tagged _and_ pushed to the remote repository) and work in progress that may be subject to change or even removal (which _won't_ be tagged, and may not even be pushed to the remote repo).
* Forget about "publishing" at fixed dates. Things will be available to the public whenever they are pushed to remote. Simple as that.

To allow the readers to track changes on design choices, I will keep a changelog with links to a _snippet_, a short doc explaining the rationale behind the change. For the sake of completeness, the changelog will track also every new feature implemented, and every bug fixed. The former will have a link to the document where the feature is explained; the latter just a short description of what has been fixed.

---

<font size="1">[**◀ Back**](../0001.md)</font>